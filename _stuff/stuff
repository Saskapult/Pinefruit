
		//
		// Texture
		//

		println!("Texture!");

		let texture_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
			entries: &[
				// Diffuse texture!
				wgpu::BindGroupLayoutEntry {
					binding: 0,
					visibility: wgpu::ShaderStages::FRAGMENT,
					ty: wgpu::BindingType::Texture {
						multisampled: false,
						view_dimension: wgpu::TextureViewDimension::D2,
						sample_type: wgpu::TextureSampleType::Float { filterable: true },
					},
					count: None,
				},
				wgpu::BindGroupLayoutEntry {
					binding: 1,
					visibility: wgpu::ShaderStages::FRAGMENT,
					ty: wgpu::BindingType::Sampler {
						// This is only for TextureSampleType::Depth
						comparison: false,
						// This should be true if the sample_type of the texture is:
						//     TextureSampleType::Float { filterable: true }
						// Otherwise you'll get an error.
						filtering: true,
					},
					count: None,
				},
				// Normal map!
				wgpu::BindGroupLayoutEntry {
					binding: 2,
					visibility: wgpu::ShaderStages::FRAGMENT,
					ty: wgpu::BindingType::Texture {
						multisampled: false,
						sample_type: wgpu::TextureSampleType::Float { filterable: true },
						view_dimension: wgpu::TextureViewDimension::D2,
					},
					count: None,
				},
				wgpu::BindGroupLayoutEntry {
					binding: 3,
					visibility: wgpu::ShaderStages::FRAGMENT,
					ty: wgpu::BindingType::Sampler { 
						comparison: false,
						filtering: true, 
					},
					count: None,
				},
		
			],
			label: Some("texture_bind_group_layout"),
		});

		let depth_texture = Texture::create_depth_texture(&device, &config, "depth_texture");


		//
		// Lights
		//

		println!("Lights!");

		let light_uniform = LightUniform {
            position: [2.0, 2.0, 2.0],
            _padding: 0,
            color: [1.0, 1.0, 1.0],
        };

        let light_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Light VB"),
            contents: bytemuck::cast_slice(&[light_uniform]),
            usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        });

        let light_bind_group_layout =
            device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
                entries: &[wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: None,
                    },
                    count: None,
                }],
                label: None,
            });

        let light_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
            layout: &light_bind_group_layout,
            entries: &[wgpu::BindGroupEntry {
                binding: 0,
                resource: light_buffer.as_entire_binding(),
            }],
            label: None,
        });


		//
		// Camera
		//

		println!("Camera!");

		let camera = Camera::new(
			Vector3::new(0.0, 0.0, 0.0), 
			UnitQuaternion::face_towards(
					&Vector3::z(),
					&Vector3::y(),
				), 
			config.width as f32 / config.height as f32, 
			0.785, 0.1, 100.0);
		let camera_controller = CameraController::new(4.0, 0.4);

		let mut camera_uniform = CameraUniform::new();
		camera_uniform.update(&camera);

		let camera_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
			label: Some("Camera Buffer"),
			contents: bytemuck::cast_slice(&[camera_uniform]),
			usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
		});

		let camera_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
			entries: &[
				wgpu::BindGroupLayoutEntry {
					binding: 0,
					visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
					ty: wgpu::BindingType::Buffer {
						ty: wgpu::BufferBindingType::Uniform,
						has_dynamic_offset: false,
						min_binding_size: None,
					},
					count: None,
				}
			],
			label: Some("camera_bind_group_layout"),
		});

		let camera_bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
			layout: &camera_bind_group_layout,
			entries: &[
				wgpu::BindGroupEntry {
					binding: 0,
					resource: camera_buffer.as_entire_binding(),
				}
			],
			label: Some("camera_bind_group"),
		});


		//
		// Render Pipeline
		//

		println!("Action! (render pipeline)");

		// All bind group layouts must be described here
		let render_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
			label: Some("Render Pipeline Layout"),
			bind_group_layouts: &[
				&texture_bind_group_layout,
				&camera_bind_group_layout,
				&light_bind_group_layout,
				],
			push_constant_ranges: &[],
    	});

		let render_pipeline = {
			println!("Shader!");
			let shader = wgpu::ShaderModuleDescriptor {
				label: Some("Normal Shader"),
				source: wgpu::ShaderSource::Wgsl(include_str!("shader.wgsl").into()),
			};
			println!("Pipeline!");
			create_render_pipeline(
				&device,
				&render_pipeline_layout,
				config.format,
				Some(Texture::DEPTH_FORMAT),
				&[Vertex::desc(), InstanceRaw::desc()],
				shader,
			)
		};

		// println!("Action again! (lights pipeline)");

		// let light_render_pipeline = {
        //     let layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        //         label: Some("Light Pipeline Layout"),
        //         bind_group_layouts: &[
		// 			&camera_bind_group_layout, 
		// 			&light_bind_group_layout,
		// 			],
        //         push_constant_ranges: &[],
        //     });
        //     let shader = wgpu::ShaderModuleDescriptor {
        //         label: Some("Light Shader"),
        //         source: wgpu::ShaderSource::Wgsl(include_str!("light.wgsl").into()),
        //     };
        //     create_render_pipeline(
        //         &device,
        //         &layout,
        //         config.format,
        //         Some(texture::Texture::DEPTH_FORMAT),
        //         &[model::ModelVertex::desc()],
        //         shader,
        //     )
        // };
		

		let instances = [
			Instance {
            	position: Vector3::new(0.0, 0.0, 0.0), 
				rotation: UnitQuaternion::from_euler_angles(0.0, 0.0, 0.0),
        	},
		].to_vec();

		let instance_data = instances.iter().map(Instance::to_raw).collect::<Vec<_>>();
		let instance_buffer = device.create_buffer_init(
			&wgpu::util::BufferInitDescriptor {
				label: Some("Instance Buffer"),
				contents: bytemuck::cast_slice(&instance_data),
				usage: wgpu::BufferUsages::VERTEX,
			}
		);

		let resources_dir = std::path::Path::new(env!("OUT_DIR")).join("res");


		
		let t_red = Texture::load(&device, &queue, &resources_dir.join("cube-diffuse-red.jpg"), TextureType::DiffuseTexture).expect("f");
		let t_blue = Texture::load(&device, &queue, &resources_dir.join("cube-diffuse-blue.jpg"), TextureType::DiffuseTexture).expect("f");
		let t_green = Texture::load(&device, &queue, &resources_dir.join("cube-diffuse-green.jpg"), TextureType::DiffuseTexture).expect("f");
		let t_n = Texture::load(&device, &queue, &resources_dir.join("cube-normal.png"), TextureType::NormalTexture).expect("f");

		let m_red = Material::new("m_red".to_string(), &t_red, &t_n, &device, &texture_bind_group_layout);
		let m_blue = Material::new("m_blue".to_string(), &t_blue, &t_n, &device, &texture_bind_group_layout);
		let m_green = Material::new("m_green".to_string(), &t_green, &t_n, &device, &texture_bind_group_layout);

		let cube_mesh = Model::from_obj(&resources_dir.join("cube.obj"), &device, &queue, &texture_bind_group_layout);

		// let cube_model = Model {
		// 	meshes: cube_mesh,
		// 	materials: ma,
		// }
		let cube_model = Model::from_obj(&resources_dir.join("cube.obj"), &device, &queue, &texture_bind_group_layout);

		let mut modelgroups = Vec::new();


		let mut cube_model_group = ModelGroup::new(&device, "cube_mg".to_string(), cube_model);
		cube_model_group.add_instance(&device, Instance {
			position: Vector3::new(0.0, 0.0, 0.0), 
			rotation: UnitQuaternion::from_euler_angles(0.0, 0.0, 0.0),
		});

		modelgroups.push(cube_model_group);

