#version 450

layout(local_size_x=16, local_size_y=16) in;

layout(set=0, binding=0) uniform Camera {
	vec4 position; // Never ever ever use a vec3, it is a cursed type
	mat4 rotation_matrix;
	float near;
	float far;
	float fovy;
	float pad;
	mat4 view;
	mat4 iview;
	mat4 projection;
	mat4 iprojection;
	mat4 view_projection;
} camera;

layout(set=1, binding=0, rgba8) uniform writeonly image2D resultImage;

layout(set=2, binding=0) readonly buffer OctreeVolumeData {
	uint contents[];
} voxel_data;
layout(set=2, binding=1) uniform ChunkAcceleratorInfo {
	ivec4 chunks_centre;
	uvec4 chunks_extent;
	uint chunk_size;
	uint chunk_st;
	uint chunk_en;

	uint colours_st;
	uint colours_en;
	
	uint n_array_volumes;
	uint array_volumes_st;
	uint array_volumes_en;
} voxel_info;


uint get_byte(uint byte_index) {
	uint contained_in = byte_index / 4;
	uint segment = byte_index % 4;
	uint bit_offset = segment * 8;
	uint mask = 0xFF << bit_offset;
	return (voxel_data.contents[contained_in] & mask) >> bit_offset;
}
uint get_4byte(uint byte_index) {
	return (get_byte(byte_index+3) << 24) + (get_byte(byte_index+2) << 16) + (get_byte(byte_index+1) << 8) + get_byte(byte_index);
}


const uint NODE_NBYTES = 4 * 10;
struct OctreeNode {
	uint[8] octants;
	uint content;
	uint leaf_mask;
};
OctreeNode node_at_byte(uint byte_index) {
	OctreeNode n;
	for (int i = 0; i < 8; i++) {
		n.octants[i] = get_4byte(byte_index + i * 4);
	}
	n.content = get_4byte(byte_index + 4 * 8);
	n.leaf_mask = get_4byte(byte_index + 4 * 9);
	return n;
}
// Byte offset for node at index
uint node_index_byte_index(uint node_index) {
	return node_index * NODE_NBYTES;
}


const uint COLOUR_NBYTES = 4;
vec4 read_colour_rgba8(uint colour_index) {
	uint byte_index = voxel_info.colours_st + colour_index * COLOUR_NBYTES;
	vec4 colour;
	colour.r = float(get_byte(byte_index+0));
	colour.g = float(get_byte(byte_index+1));
	colour.b = float(get_byte(byte_index+2));
	colour.a = float(get_byte(byte_index+3));
	colour /= 255.0;
	return colour;
}


uint chunk_at(ivec3 position) {
	bool inbounds = all(lessThanEqual(abs(position - ivec3(voxel_info.chunks_centre)), ivec3(voxel_info.chunks_extent / 2)));
	if (!inbounds) {
		return 0;
	}

	ivec3 llc = ivec3(voxel_info.chunks_centre) - ivec3(voxel_info.chunks_extent / 2);
	uvec3 corrected = uvec3(position - llc); // make relative to llc
	
	uint index = corrected.x * voxel_info.chunks_extent.y * voxel_info.chunks_extent.z + corrected.y * voxel_info.chunks_extent.z + corrected.z;
	return get_4byte(voxel_info.chunk_st + index * 4);
}



uint octree_get(uint byte_index, ivec3 vpos) {
	// bool in_bounds = all(lessThanEqual(ivec3(voxel_info.chunk_size / 2), abs(vpos - ivec3(voxel_info.chunk_size))));
	bool in_bounds = (all(lessThanEqual(vpos, ivec3(voxel_info.chunk_size-1))) && all(greaterThanEqual(vpos, ivec3(0))));
	if (!in_bounds) return 0;

	OctreeNode curr = node_at_byte(byte_index);

	uint hel = voxel_info.chunk_size / 2;
	while(true) {
		bvec3 octant_mask = greaterThanEqual(vpos, ivec3(hel));
		uint octant_idx = uint(octant_mask.x) * 4 + uint(octant_mask.y) * 2 + uint(octant_mask.z);
		uint node_index = curr.octants[octant_idx];

		uint is_leaf_mask = 1 << octant_idx;
		// If is leaf (points to content)
		if ((curr.leaf_mask & is_leaf_mask) > 0) {
			return node_index;
		}
		// If points to no new node return empty
		if (node_index == 0) {
			return 0;
		} 

		uint new_byte_index = byte_index + node_index_byte_index(node_index - 1);
		curr = node_at_byte(new_byte_index);
		vpos -= ivec3(octant_mask) * ivec3(hel);
		hel /= 2;
	}
}


vec3 bl_ray(uint chunk_byte_index, vec3 origin, vec3 direction, float tlimit, out float hit, out float t, inout vec3 normal) {
	ivec3 vpos = ivec3(floor(origin));

	ivec3 vstep = ivec3(sign(direction));
	vec3 tdelta = abs(vec3(1.0 / direction));

	vec3 tmax;
	tmax.x = direction.x < 0 ? origin.x - floor(origin.x) : 1.0 - origin.x + floor(origin.x);
	tmax.y = direction.y < 0 ? origin.y - floor(origin.y) : 1.0 - origin.y + floor(origin.y);
	tmax.z = direction.z < 0 ? origin.z - floor(origin.z) : 1.0 - origin.z + floor(origin.z);
	tmax *= tdelta;

	t = 0.0;
	hit = 0.0;
	int iters = 0;
	while (true) {
		if (iters >= 50) return vec3(0.0, 0.86, 1.0);
		if (t >= tlimit) return vec3(0.0, 0.0, 1.0);
		iters += 1;

		bool inbounds = all(lessThanEqual(vpos, ivec3(15))) && all(greaterThanEqual(vpos, ivec3(0)));

		uint v_content = octree_get(chunk_byte_index, vpos);
		if (inbounds && v_content != 0) {
			hit = 1.0;
			uint actual_content = v_content - 1;
			return vec3(read_colour_rgba8(actual_content));
		}

		if (tmax.x < tmax.y) {
			if (tmax.x < tmax.z) {
				normal = vec3(-vstep.x, 0.0, 0.0);
				vpos.x += vstep.x;
				t = tmax.x;
				tmax.x += tdelta.x;
			}
			else {
				normal = vec3(0.0, 0.0, -vstep.z);
				vpos.z += vstep.z;
				t = tmax.z;
				tmax.z += tdelta.z;
			}
		}
		else {
			if (tmax.y < tmax.z) {
				normal = vec3(0.0, -vstep.y, 0.0);
				vpos.y += vstep.y;
				t = tmax.y;
				tmax.y += tdelta.y;
			}
			else {
				normal = vec3(0.0, 0.0, -vstep.z);
				vpos.z += vstep.z;
				t = tmax.z;
				tmax.z += tdelta.z;
			}
		}
	}
	return vec3(0.0);
}


// If not hit index is 0
// If hit then index is not 0 and real index is index - 1 and t is valid
vec3 hl_ray(vec3 origin, vec3 direction, float tlimit, out float hit, out uint index, out float t) {
	float vscale = float(voxel_info.chunk_size);
	ivec3 vpos = ivec3(floor(origin / vscale));
	ivec3 vstep = ivec3(sign(direction));
	vec3 tdelta = abs(vec3(vscale / direction));

	vec3 tmax; // (fract or 1-fract depending on direction) * vscale / abs(dir)
	vec3 o = origin / vscale;
	tmax.x = direction.x < 0 ? o.x - floor(o.x) : 1.0 - o.x + floor(o.x);
	tmax.y = direction.y < 0 ? o.y - floor(o.y) : 1.0 - o.y + floor(o.y);
	tmax.z = direction.z < 0 ? o.z - floor(o.z) : 1.0 - o.z + floor(o.z);
	tmax *= tdelta;

	t = 0.0;
	hit = 0.0;
	vec3 normal = vec3(0.0);
	float hitany = 0.0;
	int iters = 0;
	while (true) {
		if (iters >= 100) return vec3(1.0, 0.0, 0.86);	// Debug purple
		if (t >= tlimit) return vec3(1.0, 0.0, 0.0);	// Red
		iters += 1;

		uint chunk_res = chunk_at(vpos);
		// if (chunk_res == 42) return vec3(1.0, 1.0, 1.0);
		if (chunk_res != 0) {
			// return vec3(0.0, 1.0, 1.0);
			uint chunk_index = chunk_res - 1;

			// Hit position relative to voxel origin
			vec3 bl_origin = origin + direction * (t + 0.001) - vec3(vpos) * vscale;
			float bl_hit;
			float bl_t;
			vec3 bl_normal = normal;
			vec3 bl_result = bl_ray(chunk_index, bl_origin, direction, 30.0, bl_hit, bl_t, bl_normal);

			if (bl_hit > 0.1) {
				float light_angle = acos(dot(bl_normal, normalize(vec3(-10.0, -15.0, -15.0))));
				float perc = 1.0 - light_angle / 3.15;

				hit = 1.0;
				// return mix(bl_result, vec3(0.0), abs(bl_normal));
				return bl_result * perc;
			}
		};

		if (tmax.x < tmax.y) {
			if (tmax.x < tmax.z) {
				normal = vec3(-vstep.x, 0.0, 0.0);
				vpos.x += vstep.x;
				t = tmax.x;
				tmax.x += tdelta.x;
			}
			else {
				normal = vec3(0.0, 0.0, -vstep.z);
				vpos.z += vstep.z;
				t = tmax.z;
				tmax.z += tdelta.z;
			}
		}
		else {
			if (tmax.y < tmax.z) {
				normal = vec3(0.0, -vstep.y, 0.0);
				vpos.y += vstep.y;
				t = tmax.y;
				tmax.y += tdelta.y;
			}
			else {
				normal = vec3(0.0, 0.0, -vstep.z);
				vpos.z += vstep.z;
				t = tmax.z;
				tmax.z += tdelta.z;
			}
		}
	}
}

 
void main() {

	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	vec3 origin = camera.position.xyz;

	vec2 uv_11space = (uv * 2.0 - vec2(1.0)) * vec2(1.0, -1.0);
	vec3 base_direction = normalize(vec3(uv_11space, camera.near));
	vec3 direction = normalize((camera.rotation_matrix * vec4(base_direction, 1.0)).xyz);


	uint index;
	float t;
	float hit;
	vec3 proto_result = hl_ray(origin, direction, 1000.0, hit, index, t);

	vec3 ppr = mix(vec3(0.1, 0.2, 0.3), proto_result, hit);

	vec4 result = vec4(ppr, 1.0);

	// vec4 result = vec4(read_colour_rgba8(4).rgb, 1.0);
	
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), result);
	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(0.5, 0.5, 0.1, 1.0));
}
