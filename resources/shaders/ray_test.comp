#version 450

// #include "voxel.glsl"

layout (local_size_x = 16, local_size_y = 16) in;
// layout (set = 1, binding = 0, rgba8) uniform readonly image2D inputImage;
layout (set = 0, binding = 0, rgba8) uniform writeonly image2D resultImage;


// https://www.shadertoy.com/view/wtSyRd
// vec3(is_hit, t_max, t_min)
vec3 aabb_intersect(vec3 origin, vec3 direction, vec3 bmin, vec3 bmax) {
	vec3 inverse_direction = 1.0 / direction;
	vec3 tbot = inverse_direction * (bmin - origin);
	vec3 ttop = inverse_direction * (bmax - origin);
	vec3 tmin = min(ttop, tbot);
	vec3 tmax = max(ttop, tbot);
	vec2 traverse = max(tmin.xx, tmin.yz);
	float traverselow = max(traverse.x, traverse.y);
	traverse = min(tmax.xx, tmax.yz);
	float traversehi = min(traverse.x, traverse.y);
	return vec3(float(traversehi > max(traverselow, 0.0)), traversehi, traverselow);
}

 
void main() {

	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	vec3 origin = vec3(0.0, 0.0, -3.0);
	vec3 direction = normalize(vec3(uv, 1.0));

	vec3 boxllc = vec3(1.2);
	vec3 boxurc = vec3(3.0);
	vec3 boxctr = (boxllc + boxurc) / 2.0;
	vec3 box = aabb_intersect(origin, direction, boxllc, boxurc);
	float is_box_hit = box.x;
	float box_t_max = box.y;
	float box_t_min = box.z;
	vec3 box_hit = boxctr - (origin + (box_t_min * direction));
	
	vec3 box_intersect_normal = box_hit / max(max(abs(box_hit.x), abs(box_hit.y)), abs(box_hit.z));
	box_intersect_normal = clamp(box_intersect_normal, vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0));
	box_intersect_normal = normalize(floor(box_intersect_normal * 1.0000001));
	
	vec4 result = vec4(mix(vec3(0.0), vec3(1.0), is_box_hit), 1.0);

	// vec3 rayO = ubo.camera.pos;
	// vec3 rayD = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ubo.aspectRatio, 1.0), -1.0));

	// imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 1.0, 0.0, 0.0));
	// vec4(uv, 0.0, 0.0)
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), result);
}
