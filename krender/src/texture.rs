use std::{path::{PathBuf, Path}, collections::{HashMap, HashSet}, num::NonZeroU32, sync::atomic::{AtomicBool, Ordering}};
use image::DynamicImage;
use parking_lot::RwLock;
use serde::{Serialize, Deserialize};
use slotmap::SlotMap;

use crate::{TextureKey, MaterialKey, BindGroupKey, prelude::BindGroupManager, RenderContextKey};



#[derive(Debug)]
pub struct TextureData {
	pub format: TextureFormat,
	pub size: wgpu::Extent3d, 
	pub source: Option<TextureSource>, // Some iff can be unloaded
	pub data: Option<TextureDataEntry>, // Saved data in RAM or disk (may be modified of original)
}
impl TextureData {
	pub fn new(format: TextureFormat, size: wgpu::Extent3d) -> Self {
		Self { format, size, source: None, data: None, }
	}

	/// Loaded immediately, slower.than load()
	/// Maybe in the future we can have an insert_many method for texture.
	/// Then we can use rayon to parallelize things. 
	/// Testing would reveal if it actually helps. 
	/// That also assumes io_uring is in effect. 
	pub fn from_file(path: impl AsRef<Path>, format: TextureFormat) -> anyhow::Result<Self> {
		let path = path.as_ref().canonicalize()?;
		let i = image::open(&path)?;
		let size = wgpu::Extent3d {
			width: i.width(),
			height: i.height(),
			depth_or_array_layers: 1,
		};

		Ok(Self { 
			format, size, 
			source: Some(TextureSource::Disk(path)), 
			data: Some(TextureDataEntry::Loaded(format.image_bytes(&i))),
		})
	}

	pub fn load(&mut self) -> Option<&[u8]> {
		if let Some(data) = self.data.as_mut() {
			match data {
				TextureDataEntry::Loaded(v) => Some(v.as_slice()),
				TextureDataEntry::Saved(_) => {
					todo!("Load into loaded, remove file, return slice");
				},
			}
		} else if let Some(source) = self.source.as_ref() {
			// Read or generate
			match source {
				TextureSource::Disk(_p) => {
					// let image = image::open(p).unwrap();
					//self.data = Some(TextureDataEntry::Loaded(self.format.image_bytes(&image)));
					// Borrow checker hates this for some reason
					todo!("Load into loaded, return slice")
				},
			}
		} else {
			None
		}
	}

	pub fn unload(&mut self) {
		fn find_free_filename(ctx: impl AsRef<Path>, max_tries: u32) -> Option<PathBuf> {
			for _ in 0..max_tries {
				let name = format!("{}.img", rand::random::<u32>());
				let path = ctx.as_ref().join(&name);
				if !path.exists() {
					return Some(path)
				}
			}
			None
		}

		if self.source.is_some() {
			self.data = None;
		} else {
			// try to make a filename
			let _p = find_free_filename("/tmp", 100)
				.expect("Failed to find a place to put this image data!");
			
			todo!("put image in file");

			// self.data = Some(TextureDataEntry::Saved(p));
		}
	}
}


#[derive(Debug, Clone)]
pub enum TextureSource {
	Disk(PathBuf),
	// Generated by function (not serializable tho!)
	// Generated by script
}


#[derive(Debug)]
pub enum TextureDataEntry {
	Saved(PathBuf),
	Loaded(Vec<u8>),
}


#[derive(thiserror::Error, Debug)]
pub enum TextureError {
	// #[error("texture data is not loaded")]
	// TextureUnloaded
}


#[derive(Debug)]
pub struct Texture {
	pub label: String,

	pub data: TextureData,

	base_usages: wgpu::TextureUsages,
	materials: RwLock<HashMap<(MaterialKey, RenderContextKey), wgpu::TextureUsages>>,
	bind_groups: RwLock<HashSet<BindGroupKey>>,
	
	mip_count: NonZeroU32,
	// Binding and whether it is dirty
	dirty: AtomicBool,
	binding: Option<BoundTexture>,
	staging: Option<Option<wgpu::Buffer>>,
}
impl Texture {
	pub fn new(
		name: impl Into<String>, 
		format: TextureFormat,
		width: u32,
		height: u32,
		depth: u32,
		readable: bool,
	) -> Self {
		let size = wgpu::Extent3d {
			width, height, depth_or_array_layers: depth,
		};
		Self {
			label: name.into(),
			data: TextureData::new(format, size),
			base_usages: wgpu::TextureUsages::empty(),
			materials: RwLock::new(HashMap::new()),
			bind_groups: RwLock::new(HashSet::new()),
			mip_count: NonZeroU32::new(1).unwrap(),
			dirty: AtomicBool::new(true),
			binding: None,
			staging: readable.then(|| None),
		}	
	}

	pub fn new_from_path(
		name: impl Into<String>, 
		path: impl AsRef<Path>,
		format: TextureFormat,
		readable: bool,
	) -> Self {
		Self {
			label: name.into(),
			data: TextureData::from_file(path, format).unwrap(),
			base_usages: wgpu::TextureUsages::COPY_DST,
			materials: RwLock::new(HashMap::new()),
			bind_groups: RwLock::new(HashSet::new()),
			mip_count: NonZeroU32::new(1).unwrap(),
			dirty: AtomicBool::new(true),
			binding: None,
			staging: readable.then(|| None),
		}
	}

	pub fn with_usages(mut self, usages: wgpu::TextureUsages) -> Self {
		self.base_usages |= usages;
		self
	}

	pub fn with_mips(mut self, mip_count: u32) -> Self {
		assert_ne!(0, mip_count);
		if mip_count > 1 {
			warn!("entering untested mip code stuff, ye be warned");
			let missing_usages = (self.base_usages & wgpu::TextureUsages::TEXTURE_BINDING) ^ wgpu::TextureUsages::all();

			if missing_usages == wgpu::TextureUsages::empty() {
				warn!("Texture {} is missing usages required for mipmapping, adding usages {missing_usages:?}", self.label);
				self.base_usages |= wgpu::TextureUsages::TEXTURE_BINDING;
			}
		}
		self.mip_count = NonZeroU32::new(mip_count).unwrap();
		self
	}

	// pub fn mean_rgba(&self) -> Result<[f32; 4], TextureError> {
	// 	let mut r = 0.0;
	// 	let mut g = 0.0;
	// 	let mut b = 0.0;
	// 	let mut a = 0.0;
	// 	let image = image::load_from_memory(self.data.data().unwrap()).unwrap();
	// 	let raw = image.to_rgba32f().into_raw();
	// 	raw.chunks_exact(4)
	// 		.for_each(|p| {
	// 			r += p[0];
	// 			g += p[1];
	// 			b += p[2];
	// 			a += p[3];
	// 		});
		
	// 	Ok([r, g, b, a].map(|v| v / (raw.len() / 4) as f32))
	// }

	pub fn total_bytes(&self) -> u32 {
		self.data.format.bytes_per_element() * self.data.size.width * self.data.size.height * self.data.size.depth_or_array_layers
	}

	pub fn set_mip_count(&mut self, mip_count: u32) {
		assert!(mip_count > 0, "Cannot have zero mips!");
		if mip_count != self.mip_count.get() {
			self.mip_count = NonZeroU32::new(mip_count).unwrap();
			self.dirty.store(true, Ordering::Relaxed);
		}
	}

	// Setting dirty here does bypass the manager, whcih will make rebuild queues not work
	pub fn set_size(&mut self, x: u32, y: u32, z: u32) {
		let new_size = wgpu::Extent3d {
			width: x, height: y, depth_or_array_layers: z,
		};
		if self.data.size != new_size {
			self.dirty.store(true, Ordering::Relaxed);
			self.data.size = new_size;
		}
	}

	pub fn rebind(
		&mut self,
		device: &wgpu::Device,
		queue: &wgpu::Queue,
		bind_groups: &BindGroupManager,
	) {
		debug!("Binding texture '{}'", self.label);

		let size = self.total_bytes() as u64;
		if let Some(staging) = self.staging.as_mut() {
			let _ = staging.insert(device.create_buffer(&wgpu::BufferDescriptor {
				label: Some(&*format!("{} staging buffer", self.label)), 
				size, 
				usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
				mapped_at_creation: true,
			}));
		}

		if self.binding.is_some() {
			trace!("Marking {} dependent bind groups as invalid", self.bind_groups.read().len());
			self.bind_groups.read().iter().for_each(|&key| bind_groups.mark_dirty(key));
		}

		self.dirty.store(false, Ordering::Relaxed);
		self.binding = Some(BoundTexture::from_texture(device, queue, self));
	}

	pub fn binding(&self) -> Option<&BoundTexture> {
		self.binding.as_ref()
	}

	/// Adds usages from material. Returns a bool indicating if the binding was invalidated. 
	/// Turns out I don't use that for anything but I keep it anyway.
	fn add_dependent_material(&self, material: MaterialKey, context: RenderContextKey, usages: wgpu::TextureUsages) -> bool {
		let current_usages = self.usages();
		self.materials.write().insert((material, context), usages);
		if current_usages | usages != current_usages {
			trace!("Texture '{}' is made invalid by an added material", self.label);
			self.dirty.store(true, Ordering::Relaxed);
			true
		} else {
			false
		}
	}

	fn remove_dependent_material(&self, material: MaterialKey, context: RenderContextKey) -> bool {
		let old_usages = self.usages();
		self.materials.write().remove(&(material, context));
		let new_usages = self.usages();
		if old_usages != new_usages {
			trace!("Buffer '{}' is made invalid by a removed material", self.label);
			self.dirty.store(true, Ordering::Relaxed);
			true
		} else {
			false
		}
	}

	fn add_dependent_bind_group(&self, bind_group: BindGroupKey) {
		self.bind_groups.write().insert(bind_group);
	}

	fn remove_dependent_bind_group(&self, bind_group: BindGroupKey) {
		self.bind_groups.write().remove(&bind_group);
	}

	pub fn usages(&self) -> wgpu::TextureUsages {
		self.materials.read().values()
			.copied()
			.fold(self.base_usages, |a, u| a | u)
	}
}


/// Wgpu TextureFormat wrapper
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone, Copy, Hash)]
pub enum TextureFormat {
	Rgba8Unorm,
	Rgba8UnormSrgb,
	Depth32Float,
	Bgra8Unorm,
	Bgra8UnormSrgb,
	R8Unorm,
}
impl TextureFormat {
	pub fn bytes_per_element(&self) -> u32 {
		match self {
			TextureFormat::Rgba8Unorm => 4,
			TextureFormat::Rgba8UnormSrgb => 4,
			TextureFormat::Bgra8Unorm => 4,
			TextureFormat::Bgra8UnormSrgb => 4,
			TextureFormat::Depth32Float => 4,
			TextureFormat::R8Unorm => 1,
		}
	}
	pub fn image_bytes(&self, image: &DynamicImage) -> Vec<u8> {
		match self {
			TextureFormat::Rgba8Unorm => image.to_rgba8(),
			TextureFormat::Rgba8UnormSrgb => image.to_rgba8(),
			_ => todo!("Figure out how to make slices of non-rgb(a) data"),
		}.into_raw()
	}
}
impl Into<wgpu::TextureFormat> for TextureFormat {
	fn into(self) -> wgpu::TextureFormat {
		match self {
			TextureFormat::Rgba8Unorm => wgpu::TextureFormat::Rgba8Unorm,
			TextureFormat::Rgba8UnormSrgb => wgpu::TextureFormat::Rgba8UnormSrgb,
			TextureFormat::Bgra8Unorm => wgpu::TextureFormat::Bgra8Unorm,
			TextureFormat::Bgra8UnormSrgb => wgpu::TextureFormat::Bgra8UnormSrgb,
			TextureFormat::Depth32Float => wgpu::TextureFormat::Depth32Float,
			TextureFormat::R8Unorm => wgpu::TextureFormat::R8Unorm,
		}
	}
}
impl From<wgpu::TextureFormat> for TextureFormat {
	fn from(fmt: wgpu::TextureFormat) -> TextureFormat {
		match fmt {
			wgpu::TextureFormat::Rgba8Unorm => TextureFormat::Rgba8Unorm,
			wgpu::TextureFormat::Rgba8UnormSrgb => TextureFormat::Rgba8UnormSrgb,
			wgpu::TextureFormat::Bgra8Unorm => TextureFormat::Bgra8Unorm,
			wgpu::TextureFormat::Bgra8UnormSrgb => TextureFormat::Bgra8UnormSrgb,
			wgpu::TextureFormat::Depth32Float => TextureFormat::Depth32Float,
			wgpu::TextureFormat::R8Unorm => TextureFormat::R8Unorm,
			_ => unimplemented!("No conversion!"),
		}
	}
}


#[derive(Debug)]
pub struct BoundTexture {
	pub texture: wgpu::Texture,
	pub view: wgpu::TextureView,
	pub size: wgpu::Extent3d,
	pub mip_count: NonZeroU32,
	pub mipped_yet: bool, // Have mipmaps been generated yet
	pub usages: wgpu::TextureUsages,
}
impl BoundTexture {
	pub fn from_texture(
		device: &wgpu::Device,
		queue: &wgpu::Queue,
		texture: &mut Texture,
	) -> Self {

		let desc = wgpu::TextureDescriptor {
			label: Some(texture.label.as_str()),
			size: texture.data.size,
			mip_level_count: texture.mip_count.into(),
			sample_count: 1,
			dimension: wgpu::TextureDimension::D2,
			format: texture.data.format.into(),
			usage: texture.usages(),
			view_formats: &[texture.data.format.into()],
		};
		let w_texture = device.create_texture(&desc);

		let view = w_texture.create_view(&wgpu::TextureViewDescriptor::default());

		let s = Self { 
			texture: w_texture, 
			view, 
			size: texture.data.size, 
			mip_count: texture.mip_count,
			mipped_yet: texture.mip_count.get() == 1,
			usages: texture.usages(),
		};

		let bytes_per_row = std::num::NonZeroU32::new(texture.data.format.bytes_per_element() * texture.data.size.width).and_then(|u| Some(u.get()));
		let rows_per_image = std::num::NonZeroU32::new(texture.data.size.height).and_then(|u| Some(u.get()));
		let size = texture.data.size;

		if let Some(data) = texture.data.load() {
			queue.write_texture(
				wgpu::ImageCopyTexture {
					aspect: wgpu::TextureAspect::All,
					texture: &s.texture,
					mip_level: 0,
					origin: wgpu::Origin3d::ZERO,
				},
				data,
				wgpu::ImageDataLayout {
					offset: 0,
					bytes_per_row,
					rows_per_image,
				},
				size,
			);
		}

		s
	}
}


#[derive(Debug, Default)]
pub struct TextureManager {
	textures: SlotMap<TextureKey, Texture>,
	textures_by_name: HashMap<String, TextureKey>,
	textures_by_path: HashMap<PathBuf, TextureKey>,
}
impl TextureManager {
	pub fn new() -> Self {
		Self {
			textures: SlotMap::with_key(),
			textures_by_name: HashMap::new(),
			textures_by_path: HashMap::new(),
		}
	}

	pub fn insert(&mut self, texture: Texture) -> TextureKey {
		let name = texture.label.clone();
		let p = if let Some(TextureSource::Disk(p)) = texture.data.source.as_ref() {Some(p.clone())} else {None};
		let idx = self.textures.insert(texture);
		self.textures_by_name.insert(name, idx);
		if let Some(p) = p {
			self.textures_by_path.insert(p, idx);
		}
		idx
	}

	pub fn remove(&mut self, key: TextureKey) {
		if let Some(texture) = self.textures.remove(key) {
			self.textures_by_name.remove(&texture.label);
		}
	}

	pub fn get(&self, key: TextureKey) -> Option<&Texture> {
		self.textures.get(key)
	}
	pub fn get_mut(&mut self, key: TextureKey) -> Option<&mut Texture> {
		self.textures.get_mut(key)
	}

	pub fn key_by_name(&self, name: &String) -> Option<TextureKey> {
		self.textures_by_name.get(name).copied()
	}

	pub fn key_by_path(&self, path: &PathBuf) -> Option<TextureKey> {
		self.textures_by_path.get(path).copied()
	}

	pub fn add_dependent_material(&self, texture: TextureKey, material: MaterialKey, context: RenderContextKey, usages: wgpu::TextureUsages) {
		if let Some(t) = self.textures.get(texture) {
			t.add_dependent_material(material, context, usages);
		} else {
			warn!("Tried to add dependent material to nonexistent texture");
		}
	}

	pub fn remove_dependent_material(&self, texture: TextureKey, material: MaterialKey, context: RenderContextKey) {
		if let Some(t) = self.textures.get(texture) {
			t.remove_dependent_material(material, context);
		} else {
			warn!("Tried to remove dependent material from nonexistent texture");
		}
	}

	pub fn add_dependent_bind_group(&self, texture: TextureKey, bind_group: BindGroupKey) {
		if let Some(t) = self.textures.get(texture) {
			t.add_dependent_bind_group(bind_group);
		} else {
			warn!("Tried to add dependent bind group to nonexistent texture");
		}
	}

	pub fn remove_dependent_bind_group(&self, texture: TextureKey, bind_group: BindGroupKey) {
		if let Some(t) = self.textures.get(texture) {
			t.remove_dependent_bind_group(bind_group);
		} else {
			warn!("Tried to remove dependent bind group from nonexistent texture");
		}
	}

	/// Bind or rebind textures
	pub fn update_bindings(&mut self, device: &wgpu::Device, queue: &wgpu::Queue, bind_groups: &BindGroupManager) {
		for (_, texture) in self.textures.iter_mut() {
			if texture.dirty.load(Ordering::Relaxed) {
				texture.rebind(device, queue, bind_groups);
			}
		}
	}

	// This function should take all unmipped textures and generate mips for them.
	// Maybe it should take an encoder? Yes, it probably should.
	// Perhaps boundtexture should have a function to decide how it is mipped based on its dimension?
	/// Must be called after bind_unbound()
	pub fn mip_unmipped(&mut self, _encoder: &mut wgpu::CommandEncoder) {
		// Iterate through all entries, if loaded check if mipped yet
		todo!()
	}
}
